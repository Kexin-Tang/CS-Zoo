# 内存淘汰 (Memory Eviction)

当Redis存储数据过大时, 需要淘汰一部分内容(即使该键值对没有过期).

## 内存淘汰策略

* 不淘汰数据
  * `noeviction` &rarr; 新数据写入会报错内存已满
* 淘汰数据
  * 在设置了过期时间的key中淘汰
    * `volatile-random` &rarr; 随机淘汰
    * `volatile-ttl` &rarr; 优先淘汰过期时间近的
    * `volatile-lru` &rarr; 优先淘汰最久未使用的
    * `volatile-lfu` &rarr; 优先淘汰使用最不频繁的
  * 在所有key中淘汰
    * `allkey-random` &rarr; 随机淘汰
    * `allkey-lru` &rarr; 优先淘汰最久未使用的
    * `allkey-lfu` &rarr; 优先淘汰使用最不频繁的

## LRU

Least Recently Used 是淘汰最久没有使用过的key. 一般的实现是通过链表, 当访问一个key的时候把该键值对放到链表的头部; 需要淘汰的时候从链表尾部开始淘汰即可.

使用链表的问题在于:
1. Reids注重内存, 而使用链表占用很多额外空间
2. 如果频繁访问Redis, 那么需要不停操作链表节点的移动

为此Redis设计了**伪LRU**: 在每个键值对中添加一个字段用于表示上一次访问的时间, 当淘汰的时候随机选择任意数量的键值对, 然后淘汰其中访问时间最久远的.

## LFU

Least Frequently Used 是淘汰一段时间内使用次数最少的key.

在Redis中其每个键值对保存两个额外字段:
* `ldt` &rarr; 上一次访问的时间戳
* `logc` &rarr; 访问频次, 值越小代表越容易被淘汰

`logc`并不是代表访问的次数, 而是一个代表频次的“评分”, 其**随时间衰减**.

> [!NOTE]
> 对于同时创建的两个键值对, 下一次访问时一个间隔短一个间隔长, 两者访问次数一致, 但频次不同.
> 
> 访问间隔越长, 频次越低, `logc`衰减越多, 值越小, 越容易被淘汰.

1. 创建键值对的时候`logc`会有一个初始值, 并记录当前时间戳到`ldt`
2. 下次访问的时候, 根据当前时间和`ldt`的差值大小决定`logc`的衰减大小 (比如每多过一分钟, `logc`就多衰减一个单位), 并更新两者的值
3. 以一定概率去增加`logc`的值, 该概率和`logc`本身的大小成反比, 即频次越高的越难增加频次


---

# 过期删除 (Expiration Deletion)

Redis可以对key设置过期的时间, 比如
* `expire <key> <n>` &rarr; n秒后过期
* `pexpire <key> <n>` &rarr; n毫秒后过期
* `expireat <key> <n>` &rarr; 到n(精确到秒)时间戳时过期
* `pexpireat <key> <n>` &rarr; 到n(精确到毫秒)时间戳时过期

## 如何判断key过期

Redis有一个专门的**过期字典**用于保存key的过期时间.

当我们操作key的时候, 使用哈希表O(1)查找过期时间并于当前时间比较, 从而决定该key还是否有效.

## 过期删除策略

* **定时删除** &rarr; 设置key的过期时间时就开启一个定时事件, 到时即删除
* **定期删除** &rarr; 每隔一段时间随机选取key检查是否过期并删掉过期的key
* **惰性删除** &rarr; 当key被访问时再检查是否过期

|策略|优点|缺点|
|---|---|---|
|定时|一旦过时就删除, 内存友好|频繁操作会占用cpu时间|
|定期|通过间隔性删除, 减少cpu负载, 也减少内存负载|折中方案, 频率太高则像定时, 频率太低则像惰性|
|惰性|只有访问的时候检查, cpu效率最高|如果key一直不被访问则一直占用内存|

Redis选择了使用**惰性删除+定期删除**, 这样既保证合理使用cpu时间又避免内存空间浪费.

其中惰性删除还是一样, 当访问key的时候进行查询, 过期则同步/异步删除(取决于设置). 对于定期删除, 其逻辑如下:
1. 随机抽取n个key进行检查
2. 删除过期的x个key
3. 如果`x/n > 25%`则立即重复步骤1; 否则等到下一个周期再执行步骤1

> [!NOTE]
> 为了防止陷入无止尽的立即重复删除而阻塞, Redis还会保证该立即循环有个时间上限