# 内存淘汰 (Memory Eviction)

## 设置运行内存

## 内存淘汰策略

---

# 过期删除 (Expiration Deletion)

Redis可以对key设置过期的时间, 比如
* `expire <key> <n>` &rarr; n秒后过期
* `pexpire <key> <n>` &rarr; n毫秒后过期
* `expireat <key> <n>` &rarr; 到n(精确到秒)时间戳时过期
* `pexpireat <key> <n>` &rarr; 到n(精确到毫秒)时间戳时过期

## 如何判断key过期

Redis有一个专门的**过期字典**用于保存key的过期时间.

当我们操作key的时候, 使用哈希表O(1)查找过期时间并于当前时间比较, 从而决定该key还是否有效.

## 过期删除策略

* **定时删除** &rarr; 设置key的过期时间时就开启一个定时事件, 到时即删除
* **定期删除** &rarr; 每隔一段时间随机选取key检查是否过期并删掉过期的key
* **惰性删除** &rarr; 当key被访问时再检查是否过期

|策略|优点|缺点|
|---|---|---|
|定时|一旦过时就删除, 内存友好|频繁操作会占用cpu时间|
|定期|通过间隔性删除, 减少cpu负载, 也减少内存负载|折中方案, 频率太高则像定时, 频率太低则像惰性|
|惰性|只有访问的时候检查, cpu效率最高|如果key一直不被访问则一直占用内存|

Redis选择了使用**惰性删除+定期删除**, 这样既保证合理使用cpu时间又避免内存空间浪费.

其中惰性删除还是一样, 当访问key的时候进行查询, 过期则同步/异步删除(取决于设置). 对于定期删除, 其逻辑如下:
1. 随机抽取n个key进行检查
2. 删除过期的x个key
3. 如果`x/n > 25%`则立即重复步骤1; 否则等到下一个周期再执行步骤1

> [!NOTE]
> 为了防止陷入无止尽的立即重复删除而阻塞, Redis还会保证该立即循环有个时间上限