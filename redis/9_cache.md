# 缓存

Redis因为保存数据在内存中, 具有较快的读写性能, 所以常被当作中间件来实现缓存, 避免频繁的磁盘读写.

## 缓存雪崩 Cache Avalanche

当把Redis用作缓存的时候, 我们会对键值对设置过期时间. 如果键值对过期了再被访问, 就需要去数据库拿数据之后返回客户端, 再由客户端放入Redis作缓存.

如果**Redis宕机**或者**某段时间大量键值对过期**, 那么大量的用户请求将直接访问数据库造成系统压力骤增, 就像雪崩一样越来越严重.

**宕机**

1. 熔断或限流 &rarr; 熔断即暂停所有访问, 限流即限制访问数量. 通过在入口处就减少数据库的访问来避免问题的累积.
2. 构建集群 &rarr; 构建集群能够提供高可用.

**大量过期**

1. 均匀设置过期时间 &rarr; 为防止都在同一时刻过期, 可以给过期时间加上随机数.
2. 互斥锁 &rarr; 业务线程处理用户请求的时候, 如果数据不在Redis则加锁, 直到从数据库拿完数据并添加进缓存之后再释放. 其他未获得锁的线程要么等待要么返回空值.
3. 分级缓存 &rarr; 越后面级别存储内容越多, 过期时间越长.
4. 不过期 &rarr; 要么不设置过期时间, 要么是使用后台线程在快过期时续时.



## 缓存击穿 Cache Breakdown

缓存击穿一般特指hot key, 如果被频繁访问的数据过期了则数据库会受到很大压力.

1. 互斥锁
2. 不过期 &rarr; 对hot key要么不设置过期时间, 要么是使用后台线程在快过期时续时.

## 缓存穿透 Cache Penetration

大量访问的数据既不在缓存也不在数据库, 也就是说缓存永远无法被建立, 所有请求都必定会访问数据库.

1. 限制请求 &rarr; 将恶意攻击的请求拦截, 比如在入口处检查是否含有恶意字段或者违反规定.
2. 缓存空值 &rarr; 既然数据不存在返回空值, 那么我们就创建一个`key: null`的键值对放入缓存.
3. 布隆过滤器 &rarr; 缓存没找到数据准备访问数据库前, 使用过滤器进行判断, 如果数据也不在数据库则不用访问.

> [!NOTE]
> 布隆过滤器由两部分组成: (1) 初始值全为0的bitmap; (2) N个不同的hash方法.
>
> 当放入一个值的时候:
> 1. 用N个hash方法得到N个输出
> 2. 将N个输出对bitmap长度取模
> 3. 将对应位置设置为1
>
> 这样当查询一个值的时候:
> 1. 用N个hash方法得到N个输出
> 2. 将N个输出对bitmap长度取模
> 3. 如果对应位置有任意一个为0, 则数据不存在
>
> 布隆过滤器的特点就是: **位图对应的不一定存在, 但位图不对应的一定不存在**.

## 对比
|雪崩|击穿|穿透|
|---|---|---|
|同时访问多个不同的数据|同时访问一个热点数据|访问的数据不存在|
|侧重于"崩", 即面广|侧重于"穿", 集中一个点|侧重于"透", 即缓存和数据库|
