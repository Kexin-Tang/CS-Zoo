# 刷题笔记总结
此处总结了一些可供参考的题目思考角度，包括某些问题常见的算法

## 堆

一般而言，堆算法都可以用来解决 <**TOP-K**> 问题，比如说如下题目:
* [23. 合并K个升序链表](./python/23.%20合并K个升序链表.md)
* [703. 数据流中的第K大元素](./python/703.%20数据流中的第K大元素.md)

---

## 数组

### 1≤a[i]≤n, n为数组长度， 求出现0/1/2次的元素

该问题一般被称为**抽屉问题**，解决此方法的最佳方式都是时间复杂度O(n)，空间复杂度O(1)的方法 —— **原数组实现哈希**

> 由条件1 ≤ a[i] ≤ n，可知出nums 中的所有值可以和其索引有对应关系
> 
> 对应关系为 nums[i]的正负值可表示 值为i + 1是否出现，若出现则将其变为加上负号，即 nums[i] *= -1,默认为正整数即未出现

* [442. 数组中重复的数据](./python/442.%20数组中重复的数据.md)
* [448. 找到所有数组中消失的数字](./python/448.%20找到所有数组中消失的数字.md)

---

## 滑动窗口

一般的题目都是要求某个数组中**最大/最小**子串, 基本来说都可以用以下的代码来作为模板

```py
def function(nums){
    n = len(nums)
    left, right =0, 0   # 窗口左右两侧
    cnt = 0             # 根据题目要求, 一般是记录某些控制窗口增加/缩小的条件
    res = 0

    for i in range(n):
        if(cnt满足某某条件):
            right += 1  # 扩大窗口
            ...
        else:
            left += 1   # 缩小窗口
            ...
    return res
}
```

* [567. 字符串的排列](./python/567.%20字符串的排列.md)
* [995. K 连续位的最小翻转次数](./python/995.%20K%20连续位的最小翻转次数.md)
* [1004. 最大连续1的个数III](./python/1004.%20最大连续1的个数III.md)

---

## 最大递增子序列(LIS)

针对 *LIS* 的题目, 都需要使用 **动态规划** 的方法. 常规的动态规划时间复杂度为O(N<sup>2</sup>), 使用二分查找的动态规划, 时间复杂度为O(N logN).

1. **动态规划的核心设计思想是数学归纳法**.

> 数学归纳法: 先假设结论在 `k<n` 时成立，然后根据这个假设，想办法推导证明出 `k=n` 的时候此结论也成立.

我们可以假设 `dp[0...i-1]` 都已经被算出来了，问题就简化为: 怎么通过这些结果算出 `dp[i]`？ 
> (`dp[i]` 表示以 `nums[i]` 这个数结尾的最长递增子序列的长度)

2. **二分查找的核心设计思想是一种扑克牌游戏**.

首先，给你一排扑克牌，我们像遍历数组那样从左到右一张一张处理这些扑克牌，最终要把这些牌分成若干堆。

只能把点数小的牌压到点数比它大的牌上；如果当前牌点数较大没有可以放置的堆，则新建一个堆，把这张牌放进去；如果当前牌有多个堆可供选择，则选择最左边的那一堆放置。

<img src="https://pic.leetcode-cn.com/8fa6beb86e462be7ee37e97ed1e5ac4980210a31e2fa43f39b0beea3e14609ef.jpeg">

牌的堆数就是最长递增子序列的长度(如上图则为5).

* [300. 最长递增子序列](./python/300.%20最长递增子序列.md)
* [354. 俄罗斯套娃信封问题](./python/354.%20俄罗斯套娃信封问题.md)

---

## 双排序

双排序问题就是一种牵涉到两个维度的排序问题, 一般情形如 `[left, right]` 或 `[width, height]` 等.

针对这种问题, 一般对**某一个维度进行正序排列, 对另一个维度进行逆序排列**. 通过这样处理后, 一般可以忽略某个维度, 只对另一个维度进行考虑, 而另一个维度通常涉及到 **动态规划** 或 **滑动窗口**.

* [354. 俄罗斯套娃信封问题](./python/354.%20俄罗斯套娃信封问题.md)

---

## 回溯

回溯问题一般涉及 “求出**所有**满足XXX条件的解”，一般都会使用 *递归* 来求解。

可以把该问题想象成一棵树，每次走一条分支，如果满足条件（能继续走），则递归到下一层；如果不满足条件（不能继续走），则返回到上一层。

```py
def helper(原数组，切片起始点start，切片终止点end，temp，结果res)：
    for i in range(start, end):
        if 不能继续走:
            res.append(temp[:])
            return
        else:
            temp.append(满足条件的子序列)
            helper(原数组，下一个起始点，下一个终止点，temp，res)
            temp.pop()  # 返回上一层时，需要把最后保存的(当前层的数据)删除
res = []
helper(s, 0, len(), []，res)
return res
```

---

## 01背包

背包问题常见的形式是：有N件物品和一个最多能被重量为 `W` 的背包。第 `i` 件物品的重量是 `weight[i]`，得到的价值是 `value[i]` 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。

此处以背包容量为4，物品如下：

|       | weight | value |
| :---: | :----: | :---: |
|   0   |   1    |  15   |
|   1   |   3    |  20   |
|   2   |   4    |  30   |


### 二维dp

1. 首先确定dp数组的含义

此处定义`dp[i][j]`表示在容量为`j`的背包中，放入`0~i`的物体，价值最大能为多少。

![初始状态.png](https://i.loli.net/2021/04/02/N9VJ5zUbFOcqDQ6.png)

2. 确定递推公式

   1. 由`dp[i - 1][j]`推出: 即背包容量为`j`，里面不放物品`i`的最大价值，此时`dp[i][j]`就是`dp[i - 1][j]`
   2. 由`dp[i - 1][j - weight[i]]`推出: `dp[i - 1][j - weight[i]]` 为背包如果要将`i`放入，要腾出的空间，腾出这么多空间后能放入的最多价值，那么`dp[i - 1][j - weight[i]] + value[i]` （物品i的价值），就是背包放物品`i`得到的最大价值

所以递归公式：`dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]] + value[i])`;

3. 初始情况

对于第一列，肯定全是`0`，因为容量为`0`，啥也放不了。

对于第一行，需要进行定义，此时只涉及物品0，因为每次都会涉及到`dp[i-1][...]`。此处需要注意：**必须反向遍历**

> 如果正向遍历，由于会访问`dp[0][i-weight[0]]`的值，而`i-weight[0]<i`，在正向遍历的时候已经设置过，所以会出现将一个物体使用多次的问题；而反向遍历，由于`i-weight[0]<i`，所以设置的时候是纯净的，没有被影响，不会重复使用。

```py
for i in range(bagWeight, weight[0]-1, -1):
    dp[0][i] = dp[0][i-weight[0]] + weight[0]  
```

4. 遍历顺序

由于`dp[i][j]`的取值取决于`dp[i-1][j]`和`dp[i-1][j-weight]`，所以都是在某一个位置的上一行或上一行偏左的位置，因此无论先遍历行还是先遍历列都OK。

![遍历顺序.png](https://i.loli.net/2021/04/02/XnAYOI62NmGscd4.png)

### 一维dp(滚动数组)

由于上述二维dp中`dp[i]j[j]`都是取决于`dp[i-1]`的情况，所以可以在上一行的基础之上分析下一行，也就是说创建一个`dp[i]`用于代表背包容量，然后每次都直接在上面改即可。

但是一定要注意，此时访问每行的时候一定要**反向遍历**！！

![滚动数组.png](https://i.loli.net/2021/04/02/8eLSn4UiGfscjtl.png)