# 刷题笔记总结
此处总结了一些可供参考的题目思考角度，包括某些问题常见的算法

## 堆

一般而言，堆算法都可以用来解决 <**TOP-K**> 问题，比如说如下题目:
* [23. 合并K个升序链表](./python/23.%20合并K个升序链表.md)
* [703. 数据流中的第K大元素](./python/703.%20数据流中的第K大元素.md)

---

## 数组

### 1≤a[i]≤n, n为数组长度， 求出现0/1/2次的元素

该问题一般被称为**抽屉问题**，解决此方法的最佳方式都是时间复杂度O(n)，空间复杂度O(1)的方法 —— **原数组实现哈希**

> 由条件1 ≤ a[i] ≤ n，可知出nums 中的所有值可以和其索引有对应关系
> 
> 对应关系为 nums[i]的正负值可表示 值为i + 1是否出现，若出现则将其变为加上负号，即 nums[i] *= -1,默认为正整数即未出现

* [442. 数组中重复的数据](./python/442.%20数组中重复的数据.md)
* [448. 找到所有数组中消失的数字](./python/448.%20找到所有数组中消失的数字.md)

---

## 滑动窗口

一般的题目都是要求某个数组中**最大/最小**子串, 基本来说都可以用以下的代码来作为模板

```py
def function(nums){
    n = len(nums)
    left, right =0, 0   # 窗口左右两侧
    cnt = 0             # 根据题目要求, 一般是记录某些控制窗口增加/缩小的条件
    res = 0

    for i in range(n):
        if(cnt满足某某条件):
            right += 1  # 扩大窗口
            ...
        else:
            left += 1   # 缩小窗口
            ...
    return res
}
```

* [567. 字符串的排列](./python/567.%20字符串的排列.md)
* [995. K 连续位的最小翻转次数](./python/995.%20K%20连续位的最小翻转次数.md)
* [1004. 最大连续1的个数III](./python/1004.%20最大连续1的个数III.md)

---

## 最大递增子序列(LIS)

针对 *LIS* 的题目, 都需要使用 **动态规划** 的方法. 常规的动态规划时间复杂度为O(N<sup>2</sup>), 使用二分查找的动态规划, 时间复杂度为O(N logN).

1. **动态规划的核心设计思想是数学归纳法**.

> 数学归纳法: 先假设结论在 `k<n` 时成立，然后根据这个假设，想办法推导证明出 `k=n` 的时候此结论也成立.

我们可以假设 `dp[0...i-1]` 都已经被算出来了，问题就简化为: 怎么通过这些结果算出 `dp[i]`？ 
> (`dp[i]` 表示以 `nums[i]` 这个数结尾的最长递增子序列的长度)

2. **二分查找的核心设计思想是一种扑克牌游戏**.

首先，给你一排扑克牌，我们像遍历数组那样从左到右一张一张处理这些扑克牌，最终要把这些牌分成若干堆。

只能把点数小的牌压到点数比它大的牌上；如果当前牌点数较大没有可以放置的堆，则新建一个堆，把这张牌放进去；如果当前牌有多个堆可供选择，则选择最左边的那一堆放置。

<img src="https://pic.leetcode-cn.com/8fa6beb86e462be7ee37e97ed1e5ac4980210a31e2fa43f39b0beea3e14609ef.jpeg">

牌的堆数就是最长递增子序列的长度(如上图则为5).

* [300. 最长递增子序列](./python/300.%20最长递增子序列.md)
* [354. 俄罗斯套娃信封问题](./python/354.%20俄罗斯套娃信封问题.md)

---

## 双排序

双排序问题就是一种牵涉到两个维度的排序问题, 一般情形如 `[left, right]` 或 `[width, height]` 等.

针对这种问题, 一般对**某一个维度进行正序排列, 对另一个维度进行逆序排列**. 通过这样处理后, 一般可以忽略某个维度, 只对另一个维度进行考虑, 而另一个维度通常涉及到 **动态规划** 或 **滑动窗口**.

* [354. 俄罗斯套娃信封问题](./python/354.%20俄罗斯套娃信封问题.md)

---

## 回溯

回溯问题一般涉及 “求出**所有**满足XXX条件的解”，一般都会使用 *递归* 来求解。

可以把该问题想象成一棵树，每次走一条分支，如果满足条件（能继续走），则递归到下一层；如果不满足条件（不能继续走），则返回到上一层。

```py
def helper(原数组，切片起始点start，切片终止点end，temp，结果res)：
    for i in range(start, end):
        if 不能继续走:
            res.append(temp[:])
            return
        else:
            temp.append(满足条件的子序列)
            helper(原数组，下一个起始点，下一个终止点，temp，res)
            temp.pop()  # 返回上一层时，需要把最后保存的(当前层的数据)删除
res = []
helper(s, 0, len(), []，res)
return res
```