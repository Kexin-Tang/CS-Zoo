# [Median of Two Sorted Arrays](https://leetcode.com/problems/median-of-two-sorted-arrays/)

## Description:
Given two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, return the median of the two sorted arrays.

*`Follow up: The overall run time complexity should be O(log (m+n))`*

 ---
 ## Example
 ```
 Input: nums1 = [1,3]
        nums2 = [2]
 Output: 2.0
 ```
 ```
 Input: nums1 = []
        nums2 = [1]
 Output: 1.0
 ```
 
 ---
 ## Solution
 ### Method 1
 首先新建一个vector，将nums1和nums2放到一起（不排序），然后使用nth_element函数找到第n大的数据并返回。该方法简单易懂，但是时间复杂度达不到`O(log (m+n))`
 ```c++
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) 
    {
        int n=nums1.size() + nums2.size();

        for(int i=0; i<nums2.size(); i++)
            nums1.push_back(nums2[i]);

        // even
        if(n%2==0)
        {
            int mid = n/2;
            double out=0.0;
            nth_element(nums1.begin(), nums1.begin()+mid, nums1.end());
            out += nums1[mid];
            nth_element(nums1.begin(), nums1.begin()+mid-1, nums1.end());
            out += nums1[mid-1];

            return out/2;
        }
        // odd
        else
        {
            int mid = (n-1)/2;
            nth_element(nums1.begin(), nums1.begin()+mid, nums1.end());
            return static_cast<double>(nums1[mid]);
        }
    }
};
 ```
 
### Method 2
将两个vector拼接的时候就进行排序，这样省去了调用nth_element，但是复杂度是`O(n+m)`，仍然不符合要求
 
### Method 3
使用二分查找
> 比如说要查找第k小的值（在该题目中，k为len1+len2+1的一半），如果nums1[mid]<nums2[mid]，那么要查找的值必定不在nums1的前半队列中，也不会在nums2的后半队列中
>> nums1=[1,2,6]<br/>
>> nums2=[3,4,5,7,8,9]<br/>
>> k=5    nums1_mid=m1='2'    nums2_mid=m2='7'=k-m1<br/>
>> nums1=[×,×,6]<br/>
>> nums2=[3,4,5,7,×,×]<br/>

> 如果把nums1和nums2的分布情况改变一下，即nums1[mid]>nums2[mid]，那么要查找的值必定在nums1的前半队列中
>> nums1=[1,6,9]<br/>
>> nums2=[2,3,4,5,7,8]<br/>
>> k=5    nums1_mid=m1='6'    nums2_mid=m2='5'=k-m1<br/>
>> nums1=[1,6,×]<br/>
>> nums2=[2,3,4,5,7,×]<br/>
```c++
class Solution {
public:
  double findMedianSortedArrays(int[] nums1, int[] nums2) 
  {
    int len1 = nums1.length;
    int len2 = nums2.length;
    if (len1 > len2) return findMedianSortedArrays(nums2, nums1); // 以nums1较短为例，如果nums1更长，则调换一下
    int k = (len1 + len2 + 1) / 2;                                // 要查找的第k小的值
    int l = 0;
    int r = len1;

    while(l < r)
    {
        int m1 = l + (r - l) / 2;      
        int m2 = k - m1;
       // situation 1 //
        if (nums1[m1] < nums2[m2 - 1])  // 如果较短的数组中间位置的值小，则必定不会在该数组前一半出现要求的值，所以只查找后一半
            l = m1 + 1;                 // nums1后一半的最左侧
        else                            // 如果较短的数组中间位置的值大，则必定出现在
            r = m1;                     // nums1前一半的最右侧
    }
    int m1 = l;
    int m2 = k - l;
    int c1 = Math.max( (m1<=0 ? Integer.MIN_VALUE : nums1[m1 - 1]), (m2<=0 ? Integer.MIN_VALUE: nums2[m2 - 1]));
    if ((len1 + len2) % 2 ==1)  // 如果是奇数，则找一个数即为中间数
      return c1;
    int c2 = Math.min( (m1>=len1 ? Integer.MAX_VALUE : nums1[m1]), (m2>=len2 ? Integer.MAX_VALUE : nums2[m2]));
    return (c1 + c2) / 2.0;
  }
}
```
