# 适用问题

在某一些题目中，需要频繁求解某个区间的`sum`或者其他操作，这种操作可以在初始化数组时进行处理，也就是使用前缀和 / 树状数组来实现。

具体而言：
* 数组不变，求区间和：「前缀和」、「树状数组」、「线段树」
* 多次修改某个数，求区间和：「树状数组」、「线段树」
* 多次整体修改某个区间，求区间和：「树状数组」、「线段树」

---

## 前缀和

前缀和顾名思义，就是使用`preSum[i]`记录`[0, ..., i]`的和，那么求解区间`[L, R]`的和就可以使用`preSum[R] - preSum[L-1]`。如果使用累加的方式，那么时间复杂度是O(n)，而使用前缀和后复杂度为O(1)。

但是，如果需要更改某一个位置`index`处的值，那么`index ~ n`内的所有前缀和需要再次更改，这样带来的时间复杂度就是O(n)，而直接使用原数组进行修改的时间复杂度为O(1)。

因此，可以看出，前缀和的特点 -- **修改缓慢，但是求和快**。

---

## 树状数组

即用数组实现树的结构。大部分基于区间上的更新以及求和问题都可以使用树状数组来求解。可以把树状数组视为简化版线段树。

### 简介

线段树长下面这样
<img src="https://img2018.cnblogs.com/blog/1448672/201810/1448672-20181003121208845-81274925.png" alt="线段树">

而树状数组如下面这样：
<img src="https://img2018.cnblogs.com/blog/1448672/201810/1448672-20181003121604644-268531484.png" alt="树状数组">

我们让`A[i]`代表原来的数组，`C[i]`代表树状数组，那么`C[i] = A[i - 2^k+1] + A[i - 2^k+2] + ... + A[i]`，其中`k`为`i`的二进制中从最低位到高位连续零的长度。
```
C[1] = A[1]
C[2] = A[1] + A[2]
C[3] = A[3]
C[4] = A[1] + A[2] + A[3] + A[4]
C[5] = A[5]
C[6] = A[5] + A[6]
C[7] = A[7]
C[8] = A[1] + A[2] + A[3] + ... + A[8]
```

### 如何求和

对于所求`sum == i`，`sum = C[i] + C[i-2^k1] + C[(i - 2^k1) - 2^k2] + .....`。其中`2^ki`为比前一个数小的最大2的次方，如 *9* 对应的为 *2<sup>3</sup>*。


### lowbit

用于求比某个数小的最大2的次方。

对于整数运算 x&(-x)有:
> * 当x为0时，即 0 & 0，结果为0；
> * 当x为奇数时，最后一个比特位为1，取反加1没有进位，故x和-x除最后一位外前面的位正好相反，按位与结果为0。结果为1。
> * 当x为偶数，且为2的m次方时，x的二进制表示中只有一位是1（从右往左的第m+1位），其右边有m位0，故x取反加1后，从右到左第有m个0，第m+1位及其左边全是1。这样，x& (-x) 得到的就是x。 
> * 当x为偶数，却不为2的m次方的形式时，可以写作x= y * (2^k)。其中，y的最低位为1。实际上就是把x用一个奇数左移k位来表示。这时，x的二进制表示最右边有k个0，从右往左第k+1位为1。当对x取反时，最右边的k位0变成1，第k+1位变为0；再加1，最右边的k位就又变成了0，第k+1位因为进位的关系变成了1。左边的位因为没有进位，正好和x原来对应的位上的值相反。二者按位与，得到：第k+1位上为1，左边右边都为0。结果为2^k。

总结一下：`x&(-x)`，当`x`为0时结果为0；`x`为奇数时，结果为1；`x`为偶数时，结果为`x`中2的最大次方的因子。

### 如何更新

当我们更新一个值`A[i]`的时候，需要更新所有带有`A[i]`的`C[j]`，由于`C[i] = A[i - 2^k+1] + A[i - 2^k+2] + ... + A[i]`，所以包含`A[i]`的有`C[i]、C[i + 2^k1]、C[(i + 2^k1) + 2^k2]...`。

### 代码模板

三个功能函数
```py
'''
计算lowbit
'''
def lowbit(x):
    return x&(-x)

'''
获得区间[1~x]的和
'''
def getSum(x, tree):
    ans = 0
    while x>0:
        ans += tree[x]
        x -= lowbit(x)
    return ans

'''
在idx位置下的数字加上val(如果传来的是diff则相当于replace值)
'''
def update(idx, val, tree):
    while idx<=len(nums):
        tree[idx] += val
        idx += lowbit(idx)
```

由于某些题目中会给tree数组设置哨兵元素，所以可能`x`和`idx`需要+1/-1等。

### 常见题目

* [307. 区域和检索 - 数组可修改](./python/307.%20区域和检索%20-%20数组可修改.md)
* [1310. 子数组异或查询](./python/1310.%20子数组异或查询.md)

---

## 线段树

线段树比较复杂，具体可以参考[这里](https://blog.csdn.net/zearot/article/details/48299459)