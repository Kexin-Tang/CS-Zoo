# [995. Minimum Number of K Consecutive Bit Flips](https://leetcode.com/problems/minimum-number-of-k-consecutive-bit-flips/)

在仅包含 `0` 和 `1` 的数组 `A` 中，一次 `K` 位翻转包括选择一个长度为 `K` 的（连续）子数组，同时将子数组中的每个 `0` 更改为 `1`，而每个 `1` 更改为 `0`。

返回所需的 `K` 位翻转的**最小次数**，以便数组没有值为 `0` 的元素。如果不可能，返回 `-1`。

 

**示例 1**：
```
输入：A = [0,1,0], K = 1
输出：2
解释：先翻转 A[0]，然后翻转 A[2]。
```

**示例 2**：
```
输入：A = [1,1,0], K = 2
输出：-1
解释：无论我们怎样翻转大小为 2 的子数组，我们都不能使数组变为 [1,1,1]。
```

**示例 3**：
```
输入：A = [0,0,0,1,0,1,1,0], K = 3
输出：3
解释：
    翻转 A[0],A[1],A[2]: A变成 [1,1,1,1,0,1,1,0]
    翻转 A[4],A[5],A[6]: A变成 [1,1,1,1,1,0,0,0]
    翻转 A[5],A[6],A[7]: A变成 [1,1,1,1,1,1,1,1]
```

**解决方法**

考虑到该题目要求最少的次数, 应该是使用**贪心算法**. 根据多次的尝试和推断, 得到结论:
> 只需要每次遍历数组的时候, 如果发现一个元素是 0, 则对从该元素开始的 K 长子序列进行翻转, 如此循环. 如果最后需要翻转的子序列索引超出数组的长度, 说明不可能实现, 应该返回 -1, 否则返回翻转次数.

* 方法一

根据上述描述, 如果 `i + K > n` 则 `return -1`. 又考虑到 0 和 1 之间的相互转换可以使用**异或**操作, 所以代码如下.

但是该方法有问题, 因为每次都需要在大的遍历下执行子序列的遍历, 即需要真正的改变元素的值, 所以时间复杂度是 O(nk).

```py
class Solution:
    def minKBitFlips(self, A: List[int], K: int) -> int:
        # 使用与1异或进行0/1转换
        i = 0
        cnt = 0
        n = len(A)
        while i<n:
            # 如果该位为1, 则继续遍历
            if A[i]:
                i+=1
                continue
            # 如果该位为0, 且后续有K个元素
            if i+K<=n:
                # 翻转k个元素
                cnt += 1
                for j in range(i, i+K):
                    A[j] = A[j]^1
            # 如果超出索引范围, 则必然失败
            else: return -1
        # 如果最后经过变换的A有两种元素(0和1), 则返回-1
        s = set(A)
        if len(s) == 2:
            return -1
        # 如果最后经过变换的A只有一种元素(1), 则返回次数
        return cnt
```

* 方法二

实际上, 并不需要真正的改变数据, 而只需要记录每个数据被翻转了多少次, 从而就能判断是否需要继续翻转, 比如:

> * 当 `A[i]` 为 0，如果 `i` 位置被翻转了偶数次，那么翻转后仍是 0，当前元素需要翻转；
> * 当 `A[i]` 为 1，如果 `i` 位置被翻转了奇数次，那么翻转后变成 0，当前元素需要翻转。

总结上述规律, 即 `(A[i] + 翻转次数) % 2 == 0` 时需要进行翻转, 所以现在的困难在**如何记录某一个位置已经翻转了多少次**.

由于设定每次翻转的子序列长度为 k, 那么说明 i 位置处翻转次数为 [0, k-1] 次, 所以可以使用一个 k 长的队列, 记录需要翻转的子序列的第一个元素下标. 

> 1. 当一个元素需要翻转时, 将该元素的 index 压入队列
> 2. 如果当前的索引已经越过了队列头部 index + k, 即意味着队列头部索引对应的子序列已经不包含当前元素, 该子序列的翻转不会影响当前元素, 那么需要弹出头部
 
那么此时, **队列的长度 == 翻转的次数**.

为了更方便理解, 可以参考[动图](https://leetcode-cn.com/problems/minimum-number-of-k-consecutive-bit-flips/solution/hua-dong-chuang-kou-shi-ben-ti-zui-rong-z403l/)

```py
class Solution:
    def minKBitFlips(self, A: List[int], K: int) -> int:
        import collections

        q = collections.deque()
        n = len(A)
        cnt = 0
        for i in range(n):
            # 如果q内有元素, 且当前index已经越过了q中保留的最先一次翻转的子序列范围时
            if q and (q[0] + K) <= i:
                q.popleft()
            
            if (len(q) + A[i]) % 2 == 0:
                if (i + K) > n:
                    return -1
                cnt += 1
                q.append(i)
        return cnt
```