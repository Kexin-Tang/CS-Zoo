# [31. 下一个排列](https://leetcode-cn.com/problems/next-permutation/)

实现获取 *下一个排列* 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须 ***原地*** 修改，只允许使用额外常数空间。

 

**示例 1**：
```
输入：nums = [1,2,3]
输出：[1,3,2]
```

**示例 2**：
```
输入：nums = [3,2,1]
输出：[1,2,3]
```

**示例 3**：
```
输入：nums = [1,1,5]
输出：[1,5,1]
```

**示例 4**：
```
输入：nums = [1]
输出：[1]
```

> 只需要测试如下的序列: `[1,2,3]`, `[3,2,1]`, `[1,5,2,3]`, `[1,5,3,2]`, `[3,5,2,3]`, `[3,5,3,2]`，如果全都正确，则AC

**解决方法**

由于需要换到字典序中下一个更大的排列，所以是尽量先改变右边的位，所以考虑从右往左遍历。

比如说`[1,5,3,2]`的结果应该为`[2,1,3,5]`，即先从右往左，如果递增，则继续遍历：
1. 遍历到头都是递增，即形如`[3,2,1]`，则直接翻转整个数组
2. 如果发现一个下降，则将第一个下降设置为要替换的元素`a`，下标为`i-1`，再次从右往左遍历([i, ..., n-1])，发现第一个比`a`大的元素`b`，则交换两者，如`[1,5,3,2]`&rarr;`[2,5,3,1]`。然后再将[i, ..., n-1]进行翻转即可，即`[2,5,3,1]`&rarr;`[2,1,3,5]`。

```python
class Solution:
    def nextPermutation(self, nums) -> None:
        n = len(nums)
        for i in range(n-1, 0, -1):
            if nums[i]>nums[i-1]:
                for j in range(n-1, i-1, -1):
                    if nums[j]>nums[i-1]:
                        nums[i-1], nums[j] = nums[j], nums[i-1]
                        break
                nums[i:] = nums[-1:i-1:-1]
                return
        nums.reverse()
```