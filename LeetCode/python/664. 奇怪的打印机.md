# [664. 奇怪的打印机](https://leetcode-cn.com/problems/strange-printer/)

有台奇怪的打印机有以下两个特殊要求：

* 打印机每次只能打印由 *同一个字符* 组成的序列。

* 每次可以在任意起始和结束位置打印新字符，并且会覆盖掉原来已有的字符。

给你一个字符串 s ，你的任务是计算这个打印机打印它需要的最少打印次数。

 
**示例 1**：
```
输入：s = "aaabbb"
输出：2
解释：首先打印 "aaa" 然后打印 "bbb"。
```

**示例 2**：
```
输入：s = "aba"
输出：2
解释：首先打印 "aaa" 然后在第二个位置打印 "b" 覆盖掉原来的字符 'a'。
```

## 解决方法

对于`a`，只需要打印一次。

对于`aa`，只需要打印一次。

对于`ab`，要打印两次，即`a`和`b`。

对于`aba`，只要打印两次，因为开头和末尾都是`a`，所以`aba`的次数==`ab`的次数。

对于`abab`，需要打印三次，因为开头和末尾不同，所以相当于遍历`a + bab`、`ab + ab`和`aba + a`三种情况中最小的。

根据上述分析，可以使用一个`dp[l][r]`数组，其中`l`为left，`r`为right，表示`l~r`内需要打印的次数。其转移方程：

* 如果首尾相同，那么`dp[l][r] = dp[l][r-1]`，即形如`aba`取决于`ab`一样
* 如果首位不同，那么设置`k`在`l~r`内，求取`dp[l][k]+dp[k+1][r]`的最小值作为结果

注意，由于求`r`的时候可能使用到`r-1`，所以`r`是从小到大(从左到右)遍历。由于当`l==r`时(只打印单字符)肯定为1，且长字串依赖于短字串，所以字串是由短边长，即`l`是从大到小(从右到左，但是不超过`r`)。

```py
class Solution:
    def strangePrinter(self, s: str) -> int:
        n = len(s)
        dp = [[float('inf') for _ in range(n)] for _ in range(n)]
        
        for r in range(n):
            # 遍历到单字符，打印次数为1
            dp[r][r] = 1
            # 从右向左遍历`l`，不断扩大字串长度
            for l in range(r-1, -1, -1):
                # 如果首尾相同
                if s[l] == s[r]:
                    dp[l][r] = dp[l][r-1]
                # 如果首尾不同
                else:
                    # 设置k介于l~r，分割字串，分别求解两边子串的情况
                    for k in range(l, r):
                        dp[l][r] = min(dp[l][r], dp[l][k] + dp[k+1][r])

        return dp[0][-1]
```