# [932. 漂亮数组](https://leetcode-cn.com/problems/beautiful-array/)

对于某些固定的 N，如果数组 A 是整数 1, 2, ..., N 组成的排列，使得：

对于每个 i < j，都不存在 k 满足 i < k < j 使得 A[k] * 2 = A[i] + A[j]。

那么数组 A 是漂亮数组。

给定 N，返回任意漂亮数组 A（保证存在一个）。

 

**示例 1**：
```
输入：4
输出：[2,1,4,3]
```

**示例 2**：
```
输入：5
输出：[3,1,2,5,4]
```

## 解决方法

由于要求 `nums[k]*2 != nums[i]+nums[j]`，而等号左侧必为偶数，因此右侧必须为偶数+奇数。对于从1~N而言，有 *(N+1)//2* 个奇数，*N//2* 个偶数。也就是我们要新建一个数组，数组长度为N，所有奇数都在前半部分，所有偶数都在后半部分。

还有要用到的数学知识是，如果一个数组是漂亮数组，那么其线性变换之后的数组也是漂亮数组，即如果[x1, x2, x3]是一个漂亮数组，则[k * x1 + b, k * x2 + b, k * x3 + b] 也一定是漂亮数组。

* 对于从1到(N + 1)/2的所有整数x，得出其漂亮数组，并映射成1到N范围的所有奇数 2 * x - 1
* 对于从1到N/2的所有整数x，得出其漂亮数组，并映射成1到N范围的所有偶数 2 * x

由于求较大的N时会利用到前面已经求解过的内容，因此我们使用hash记录之前的内容。

```py
class Solution:
    def beautifulArray(self, N: int) -> List[int]:
        memo = {1 : [1]}
        def f(N):
            if N not in memo:
                memo[N] = [2 * x - 1 for x in f((N + 1) // 2)] + [2 * x for x in f(N // 2)]
            return memo[N]
        return f(N)
```