# [927. 三等分](https://leetcode-cn.com/problems/three-equal-parts/)

给定一个由 0 和 1 组成的数组 A，将数组分成 3 个非空的部分，使得所有这些部分表示相同的二进制值。

如果可以做到，请返回任何 [i, j]，其中 i+1 < j，这样一来：

A[0], A[1], ..., A[i] 组成第一部分；
A[i+1], A[i+2], ..., A[j-1] 作为第二部分；
A[j], A[j+1], ..., A[A.length - 1] 是第三部分。
这三个部分所表示的二进制值相等。
如果无法做到，就返回 [-1, -1]。

注意，在考虑每个部分所表示的二进制时，应当将其看作一个整体。例如，[1,1,0] 表示十进制中的 6，而不会是 3。此外，前导零也是被允许的，所以 [0,1,1] 和 [1,1] 表示相同的值。
 

**示例 1**：
```
输入：[1,0,1,0,1]
输出：[0,3]
```

**示例 2**：
```
输出：[1,1,0,1,1]
输出：[-1,-1]
```

## 解决方法

由于需要将数组分为三份，每一份的二进制数字相同。由于可能有前缀0干扰，所以我们可以根据1的数量进行划分：**每一份中1的个数要相同**。同时，后缀0会影响二进制数字大小，所以后缀0也需要考虑：由于最后一份的结尾一定是数组的末尾，所以我们可以直接获知**每一份中后缀0的个数 *lastZeros***。

通过确定每一份中1的个数为 *one*，那么我们可以找到三份区间的首个为1的元素下标。然后通过同时遍历这三份的元素，直到遍历完后缀0(即最后一份遍历到数组结尾)。

```py
class Solution:
    def threeEqualParts(self, arr: List[int]) -> List[int]:

        # 由于要求三个部分的值相同，所以需要把1的个数进行三等分
        oneNumbers = arr.count(1)
        
        # 如果arr全为0，则返回[0, n-1]
        if oneNumbers == 0:
            return [0, len(arr)-1]

        # 如果1的个数无法三等分，则必定不满足条件
        if oneNumbers%3:
            return [-1, -1]
        
        one = oneNumbers // 3   # 每个区间内1的个数
        
        # 由于最后一部分的末尾一定是arr的末尾，且三个部分值要相同，意味着低位的0的个数要相同
        # 因此统计一下最后一部分的低位有lastZeros个0
        i = len(arr)-1
        lastZeros = 0
        while arr[i] == 0:
            lastZeros += 1
            i -= 1

        def findThreeBegin():
            '''
            找到三个部分的最左侧1对应的下标
            '''
            p = []
            temp = one
            for i in range(len(arr)):
                if arr[i] == 1:
                    if temp == one: # 如果是第一个1，则记录下标
                        p.append(i)
                    temp -= 1
                    if temp == 0:   # 如果一个区间遍历完成，则重置计数
                        temp = one
            return p
        
        p1, p2, p3 = findThreeBegin()
        # 忽略前缀0，剩下有效的部分由[p3, n-1]决定，因此只需要遍历p3至末尾
        while p3<len(arr):
            # 如果某一位上出现不同，则返回[-1, -1]
            if arr[p1] != arr[p2] or arr[p1] != arr[p3] or arr[p2] != arr[p3]:
                return [-1, -1]
            p1 += 1
            p2 += 1
            p3 += 1

        return [p1-1, p2]
```