# [260. 只出现一次的数字 III](https://leetcode-cn.com/problems/single-number-iii/)

给定一个整数数组 `nums`，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 **任意顺序** 返回答案。

*你的算法应该具有线性时间复杂度，且仅使用常数空间复杂度来实现!*

 

**示例 1**：
```
输入：nums = [1,2,1,3,2,5]
输出：[3,5]
解释：[5, 3] 也是有效的答案。
```

**示例 2**：
```
输入：nums = [-1,0]
输出：[-1,0]
```

**示例 3**：
```
输入：nums = [0,1]
输出：[1,0]
```

**解决方法**

在[136. 只出现一次的数字](./136.%20只出现一次的数字.md)中，对于重复两次的元素可以使用**异或**进行消除，但是此处只能得到所求的两个值异或的结果，比如设置要求解的为 *x*，*y*，那么对`nums`求异或只能得到 *x^y*。
> 由于异或的原理就是相同的元素&rarr;0，不同元素&rarr;1，所以根据 *x^y* 可以获知在某一位上，他们两个一个取 *1* 一个取 *0*。

在[137. 只出现一次的数字 II](137.%20只出现一次的数字%20II.md)中，对每一位为1的进行计数，可以使用取余是否为0判断，但是此处由于有两个元素要求，也只能找出那些 *x* 和 *y* 取值不同的位。
> 比如 *x* 和 *y* 在第 *i* 位取了 *1* 和 *0*，那么`alpha[i]%2!=0`，但是对于在第 *j* 位取一样的数字时，无法获知是取的*0*还是*1*

那么就要利用这些已知的取值必定不同的位。

利用[136. 只出现一次的数字](./136.%20只出现一次的数字.md)的思想，如果我们可以把所有数字分成两组，使得：

1. 两个只出现一次的数字在不同的组中；

2. 相同的数字会被分到相同的组中。

那么对两个组分别进行异或操作，即可得到答案的两个数字。

具体而言，只要找到任意一个 *x^y* 中为 *1* 的位作为判断的依据即可。比如第 *i* 位处，*x^y == 1*，那么所有第 *i* 位为 *1* 的元素放到一组，所有第 *i* 位为 *0* 的放到一组，就必定实现上述的两个要求。

```py
class Solution:
    def singleNumber(self, nums: List[int]) -> List[int]:
        temp = 0                # 最终会保存a^b
        for num in nums:
            temp = temp^num
        
        div = 1                 # 保存a和b不一样的bit位
        while div&temp == 0:
            div <<= 1
        
        ans1, ans2 = 0, 0
        for num in nums:
            if num&div == 0:
                ans1 ^= num
            else:
                ans2 ^= num
        
        return [ans1, ans2]
```
