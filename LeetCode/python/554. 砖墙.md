# [554. 砖墙](https://leetcode-cn.com/problems/brick-wall/)

你的面前有一堵矩形的、由 `n` 行砖块组成的砖墙。这些砖块高度相同（也就是一个单位高）但是宽度不同。**每一行砖块的宽度之和应该相等**。

你现在要画一条自顶向下的、穿过 **最少** 砖块的垂线。如果你画的线只是从砖块的边缘经过，就不算穿过这块砖。你不能沿着墙的两个垂直边缘之一画线，这样显然是没有穿过一块砖的。

给你一个二维数组 `wall` ，该数组包含这堵墙的相关信息。其中，`wall[i]` 是一个代表从左至右每块砖的宽度的数组。你需要找出怎样画才能使这条线穿过的砖块数量最少 ，并且返回穿过的砖块数量 。

**示例**：

<img src="https://assets.leetcode.com/uploads/2021/04/24/cutwall-grid.jpg">

```
输入：wall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]
输出：2
```

**解决方法**

因为要想办法穿过最少的砖块，那么就要求这条线必须经过尽量多的砖块边界，所以这是一个**贪心**的过程。

假设 `wall` 一共有 `n` 层，有 `k` 层的砖的右侧都在同一垂直线上，那么需要穿过的砖块数为 `n-k`。由于 `n` 是固定的，所以就要求 `k` 最大。

因此该问题转换为：
1. 求出每一行砖块的右边界所在的坐标(假设墙的最左边界为原点)
2. 求出坐标中出现次数最多的作为划分线所在的坐标，即`k`最大

> 针对给出的解析，我们可以求出其坐标为 
> ```
> [[1, 3, 5, 6], 
>  [3, 4, 6],
>  [1, 4, 6],
>  [2, 6],
>  [3, 4, 6],
>  [1, 4, 5, 6]]
> ```
> 其中`6`出现最多，但是因为出现最多的肯定是最右边界，不满足题目要求，所以真正要求的是出现第二多的元素，也就是`4`，一共出现了`4`次，所以答案就是`6-4=2`块砖

我们使用**哈希表**来存储右边界坐标，并设置格式为`{边界坐标: 出现次数}`

```py
class Solution:
    def leastBricks(self, wall: List[List[int]]) -> int:
        hash_table = {}
        # 遍历每一行
        for row in wall:
            right = 0           # 右侧坐标，起始为0
            # 遍历每一个砖
            for col in row:
                right += col    # 更新右侧坐标
                # 更新坐标出现次数
                if right in hash_table:
                    hash_table[right] += 1
                else:
                    hash_table[right] = 1
        # 如果每一层的砖都只有一块，且都等长，如[[1],[1],[1]]
        if len(hash_table)<2:
            return len(wall)

        # 哈希表根据value进行排序     
        cnt = [hash_table[k] for k in hash_table.keys()]
        cnt.sort()
        # 返回 总行数-第二大的出现次数
        return len(wall)-cnt[-2]
```