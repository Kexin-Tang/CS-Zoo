# [330. 按要求补齐数组](https://leetcode-cn.com/problems/patching-array/)

给定一个已排序的正整数数组 nums，和一个正整数 n 。从 [1, n] 区间内选取任意个数字补充到 nums 中，使得 [1, n] 区间内的任何数字都可以用 nums 中某几个数字的和来表示。请输出满足上述要求的最少需要补充的数字个数。

**示例 1**:
```
输入: nums = [1,3], n = 6
输出: 1 
解释:
根据 nums 里现有的组合 [1], [3], [1,3]，可以得出 1, 3, 4。
现在如果我们将 2 添加到 nums 中， 组合变为: [1], [2], [3], [1,3], [2,3], [1,2,3]。
其和可以表示数字 1, 2, 3, 4, 5, 6，能够覆盖 [1, 6] 区间里所有的数。
所以我们最少需要添加一个数字。
```

**示例 2**:
```
输入: nums = [1,5,10], n = 20
输出: 2
解释: 我们需要添加 [2, 4]。
```

**示例 3**:
```
输入: nums = [1,2,2], n = 5
输出: 0
```

## 解决方法

假设 1～x-1 范围内所有元素都存在：

1. 如果 x 不存在，那么我们需要加入一个 x，1～x+(x-1) 即 1～2x-1 也必然存在，都可以不用考虑，直接跳转到 2x 继续判断。
2. 如果 x 就是nums中给定的元素，那么下一步最远可以到达的位置为 x+nums[i]
3. 如果 x 已经跨过了某个nums中给定的元素，那么下一步最远可以到达的位置为 x+nums[i]

由于存在跳转，就有多种情况：

```
a _ _ _ _ b _ _ _ _

1. a x _ _ _ b _ _ _ _ 即跳转后和下一个nums中给定的元素还有一定的空隙，那么在下一轮循环中会继续增加一个x然后跳转到新的2x
     x   2x

2. a x _ _ b _ _ _ _ 即跳转后跨过了nums中下一个元素，此时我们最远能确定“一定可以到达”的位置是 b+x，所以我们进一步跳转到最远的可确定位置
     x         2x

```

```py
class Solution:
    def minPatches(self, nums: List[int], n: int) -> int:
        ans = 0
        index = 0
        p = 1
        while p<=n:
            if index<len(nums) and nums[index]<=p:
                p = p+nums[index]
                index += 1
            else:
                p = p*2
                ans += 1
        return ans
```