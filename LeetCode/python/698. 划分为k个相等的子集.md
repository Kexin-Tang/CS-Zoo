# [698. 划分为k个相等的子集]()

给定一个整数数组 `nums` 和一个正整数 `k`，找出是否有可能把这个数组分成 `k` 个非空子集，其总和都相等。

**示例 1**：
```
输入： nums = [4, 3, 2, 3, 5, 2, 1], k = 4
输出： True
说明： 有可能将其分成 4 个子集（5），（1,4），（2,3），（2,3）等于总和。
```

---

## 解决方法

由于要求分成`k`个组，每个组的和相同，那么这个和就是`sum(nums)//k`，因此，可以首先判断是否能整除，如果不能整除，则肯定不符合要求，返回`False`。

在确定了`target`作为和之后，需要进行回溯，设置`k`个分组组成的list`groups`，每次遍历到一个`nums[i]`则尝试将其放入每一个组内：如果当前分组能够容纳下该元素（相加后不会超出target），则放入，并递归下一个元素；如果不能容纳，则换组。如果循环结束，每个组都放不下，则不符合要求，返回`False`。

由于直接回溯会遍历大量没有必要的情况，所以需要剪枝：

1. 数组内存在大于target的元素 -- 首先对`nums`进行排序，如果`nums[-1]>target`，则直接返回`False`，不用进行回溯；
2. 数组内有等于target的元素 -- 由于上面一种情况已经排序+排除有大于`target`的了，所以此处看`nums[-1] ?= target`
   1. 如果小于，那么`nums`内所有元素都会小于`target`
   2. 如果等于，那么可以假设直接将其放入一个组，组数`k--`，不考虑该元素`nums.pop()`。即相当于考虑了一个子问题。
3. `if groups[i] == 0: break`

```
以数组为[10,10,10,7,7,7,7,7,7,6,6,6]，分成3部分为例，即分成3个桶，每个桶的和为30

排序后数组为[6,6,6,7,7,7,7,7,7,10,10,10]，需要放在3个桶中，每个桶的和为30

第一层递归，末尾的10放在第一个桶中
|   |   |   |   |   |
|   |	|   |   |   |
|   |	|   |   |   |
|10 |	|   |   |   |
 ---	 ---	 ---
桶1      桶2      桶3

第二层和第三层递归，倒数第二个和倒数第三个10都放在桶1中
|   |   |   |   |   |
|10 |	|   |   |   |
|10 |	|   |   |   |
|10 |	|   |   |   |
 ---	 ---	 ---
桶1      桶2      桶3

第四层递归，倒数第一个7就不能放在桶1中了，因为30+7>30，所以放在桶2中
|   |   |   |   |   |
|10 |	|   |   |   |
|10 |	|   |   |   |
|10 |	|7  |   |   |
 ---	 ---	 ---
桶1      桶2      桶3

后续直到桶2中放了4个7，

|   |   |7  |   |   |
|10 |	|7  |   |   |
|10 |	|7  |   |   |
|10 |	|7  |   |   |
 ---	 ---	 ---
桶1      桶2      桶3

再有7就不能放到桶2中了，因为5*7>30

后续的2个7和2个6放到了桶3中

|   |   |7  |   |6  |
|10 |	|7  |   |6  |
|10 |	|7  |   |7  |
|10 |	|7  |   |7  |
 ---	 ---	 ---
桶1      桶2      桶3

正数第一个6这时没地方放了，因为放到任何一个桶中，都大于30，这时遍历3个桶，都没法放进去之后，返回false。

递归返回到正数第二个6，正数第二个6从桶3中出栈，但是没有桶4可以让正数第二个6放进去了，for循环直接结束了，同时返回false

同理，桶3中的元素会依次从桶3中出栈

然后桶2中的栈顶的7，会尝试放到桶3中，再递归下去，（剩余的数组元素为[6,6,6,7,7])

|   |   |   |   |   |
|10 |	|7  |   |   |
|10 |	|7  |   |   |
|10 |	|7  |   |7  |
 ---	 ---	 ---
桶1      桶2      桶3

最终桶2中的元素，会全部依次出栈，此时数组中剩余的元素为[6,6,6,7,7,7,7,7,7]

|   |   |   |   |   |
|10 |	|   |   |   |
|10 |	|   |   |   |
|10 |	|   |   |   |
 ---	 ---	 ---
桶1      桶2      桶3

如果没有 if (groups[i] == 0) break; 这行代码，我们知道了桶2已经是空了，但是仍然会运行for循环，把倒数第一个位置的7，放到桶3中再次尝试，并继续递归下去。但是这样其实没有意义，因为桶2和桶3的地位是一样的，这种情况也是无解的，所以可以剪枝。
```

```py
class Solution:
    def canPartitionKSubsets(self, nums: List[int], k: int) -> bool:
        target, rem = sum(nums)//k, sum(nums)%k
        
        # 如果不能整除，那么肯定不能分割成总和相等的情况
        if rem: return False

        groups = [0 for _ in range(k)]  # 分成k个组，每个组初始化都为0，表示没有元素

        def helper(groups):
            # 如果已经将所有数字都分配完成，那么任务完成
            if not nums:
                return True
            
            num = nums.pop()
            for i in range(k):
                if groups[i]+num <= target:
                    groups[i] += num
                    # 如果找到满足要求的，则直接不用继续了，一路绿灯返回True
                    if helper(groups):
                        return True
                    groups[i] -= num
                # 重要的剪枝步骤
                if groups[i] == 0:
                    break
            nums.append(num)
            return False
        
        nums.sort()
        # 如果有大于target的元素，那么必定不满足条件，返回False
        if nums[-1]>target: 
            return False
        # 如果有等于target的单个数字 则将其先进行处理
        while nums and nums[-1]==target:
            nums.pop()
            k-=1
        # 如果k=0 或者 剩下的nums里的值全是0，则返回true
        if k==0 or not any(nums): return True

        return helper(groups)
```