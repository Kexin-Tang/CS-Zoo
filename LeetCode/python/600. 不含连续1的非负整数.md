# [600. 不含连续1的非负整数](https://leetcode-cn.com/problems/non-negative-integers-without-consecutive-ones/)

给定一个正整数 n，找出小于或等于 n 的非负整数中，其二进制表示不包含 连续的1 的个数。

**示例**:
```
输入: 5
输出: 5
解释: 
下面是带有相应二进制表示的非负整数<= 5：
0 : 0
1 : 1
2 : 10
3 : 11
4 : 100
5 : 101
其中，只有整数3违反规则（有两个连续的1），其他5个满足规则。
```

## 解决方法

假设我们要找到 n 位不包含连续 1 的数字，我们可以用递归的视角看待这个问题。假设 f[i] 求出了 i 位符合要求二进制串的数目，为了求出 f[n]，我们考虑如下情况。

<img src="https://pic.leetcode-cn.com/7a6be26e5a406c8572b07d079280e6277898d9cbd5125f743817aed0529975c4-image.png">

从上图中，我们可以知道如果我们知道 f[n−1] 和 f[n−2] 的值，为了求出需要的 n 位数字，我们可以给 f[n−1] 中所有数字后面添加 0，这样不会产生任何不合法数字。这些数字使得 f[n] 中会包含 f[n−1] 的结果。但我们不能直接给所有这些数字后加 1，因为可能会导致有连续 1 出现。所以如果我们要在后面加 1，我们必须确保上一个位置是 0。所以我们必须一次性给 f[n-2] 中的字符串最后面加 01。所以我们得到了递推式 `f[n]=f[n−1]+f[n−2]`。

现在我们回到解法中，我们试着通过两个简单的例子来理解背后的想法。首先我们考虑给定数字不包含任何连续 1。比方说 num=1010100 （7位），现在我们需要思考如何找到比 num 小的无连续 1 的数字。我们从 num 的最高位开始考虑，如果我们固定住最高位为 0，然后找 6 位没有连续 1 的数字，也就是从 **0**000000 到 **0**111111，我们可以用上面讨论的 f[6] 来得到答案。

但即使这样做了以后，要求范围内的数字并没有被全部覆盖到。现在我们固定最高位为 1，那么考虑的数字范围会从 **1**000000 到 **1**111111，我们可以看出来除了要求的 **1**000000 到 **1**010100 以外，还包括了这个范围以外的一些数字。所以我们不能仅把最高位固定为 1 然后直接考虑低 6 位的值。

为了考虑剩余范围，我们首先固定最高位为 1 ，然后继续处理第二高位。由于我们在 num 中得到第二高位是 0 ，所以我们不能将它变成 1 ，这会导致数字超过 num 。但如果我们直接把这一位设为 }0 并取所有更低位不包含连续 1 的话，覆盖的范围是 **10**0000 到 **10**1111 ，再一次我们发现这些数字包括了一些范围以外的数字。所以我们需要继续考虑低 5 位的情况。

我们将第二高位固定为 0 再继续考虑第三位，这次我们又遇到了 1，像第一位一样，我们可以将这一位固定为 1，并获取低 4 位没有连续 1 的数字数目，这个值可以直接通过 f[4] 获得。所以现在覆盖到的数字范围是 **100**0000 到 **100**1111。

我们将第三高位固定为 1 再继续考虑第四位，又一次是 0，所以我们需要像第二位一样将它固定，然后考虑第五位。第五位是 1，我们将它固定为 0 并获取剩下 2 位的所有合法序列，即 **10101**00 到 **10101**11，然后考虑第 6 位，发现再次是 0，所以我们固定第六位为 0 再考虑第 7 位，发现仍然是 0，于是也将这一位固定为 0。

现在，我们可以发现，基于以上过程，数字范围在 **0**000000 到 **0**111111，**100**0000 到 **100**1111，**10100**00 到 **10100**11，都已经分别由 f[6]，f[4]，f[2] 求出来了。现在只有 1010100 需要考虑是否要包括进来。因为它不包含任何连续的 1，所以我们给最后的答案加 1，也就是答案为 f[6]+f[4]+f[2]+1。


---

现在我们考虑一下 num 中包含连续 1 的情况，基本想法与上面一致，除了遇到连续 1 的时候有所不同。比方说 num=1011010 ，如上所述，我们从最高位开始考虑，我们发现是 1 ，然后我们将它固定为 0 得到范围 **0**000000 到 **0**111111 的合法数字。这个值同样由 f[6] 给出。

现在固定最高位是 1 然后考虑次高位，它是 0 ，所以我们没有别的选择只能将它固定为 0 然后考虑第三高位。这一位是 1 ，所以我们可以固定这一位是 0 并考虑范围在 **100**0000 到 **100**1111 的合法数字，可以由 f[4] 求出，然后我们固定第三高位为 1 考虑第四位。它仍然是 1 （与前一个数字 1 构成了 连续 1）。选择我们固定这一位为 0 ，考虑数字范围 **1010**000 到 **1010**111 的合法数字，数目为 f[3] 。

我们可以发现，目前为止范围在 **0**0000000 到 **0**111111 ， **100**0000 到 **100**1111 , **1010**000 到 **1010**111 的数字范围都被考虑过了，但如果我们考虑任何大于 **1010**111 的数字，都会导致第三位和第四位有连续 1 出现。所以所有有效数字的数目为 f[6]+f[4]+f[3] 。

所以，综合上面讨论的内容，我们从 num 的最高位开始考虑，对于第 i 个位置遇到的 1 （从低位序号为 0 开始考虑），我们将答案加 f[i] ，对每个遇到的 0 ，我们不给答案加任何值。我们还要记录上一个位置的数值为多少，一旦我们发现连续的 1 ，我们将第二个 1 变成 0 的影响考虑后即停止遍历。如果我们没有遇到连续的 1 ，我们一直遍历到最低位并将最终答案加 1 ，表示 num 也是合法数字，因为上述过程并没有考虑 num 进去。

```py
class Solution:
    def findIntegers(self, n: int) -> int:
        bits = 0
        
        # bits 代表了有效的二进制位数
        while n >> bits:
            bits += 1
        
        f = [0 for _ in range(bits + 1)]
        f[0] = 1
        f[1] = 2
        for i in range(2, bits + 1):
            f[i] = f[i - 2] + f[i - 1]

        res = 0
        pre_bit = 0                     # 前一位是0 还是1
        while bits >= 0:
            if (n & (1<<bits)):
                res += f[bits]
                if pre_bit == 1:        # 前一个bit为1，即出现连续1
                    res -= 1            # 此处-1是因为最后返回的为ans+1，而ans+1考虑了整个数字都不含连续1的情况
                    break               # 遇到一个连续1的时候后面就不用讨论了，直接返回
                pre_bit = 1
            else:
                pre_bit = 0

            bits -= 1
        
        return res + 1              #上面的过程 没有考虑num
```