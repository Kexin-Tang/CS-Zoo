# [552. 学生出勤记录 II](https://leetcode-cn.com/problems/student-attendance-record-ii/)

可以用字符串表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：

* 'A'：Absent，缺勤
* 'L'：Late，迟到
* 'P'：Present，到场

如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励：

* 按总出勤计，学生缺勤（'A'）严格少于两天。
* 学生不会存在连续 3 天或连续 3 天以上的迟到（'L'）记录。

给你一个整数 n ，表示出勤记录的长度（次数）。请你返回记录长度为 n 时，可能获得出勤奖励的记录情况 数量 。答案可能很大，所以返回对 10<sup>9</sup> + 7 取余 的结果。


**示例 1**：
```
输入：n = 2
输出：8
解释：
有 8 种长度为 2 的记录将被视为可奖励：
"PP" , "AP", "PA", "LP", "PL", "AL", "LA", "LL" 
只有"AA"不会被视为可奖励，因为缺勤次数为 2 次（需要少于 2 次）。
```

**示例 2**：
```
输入：n = 1
输出：3
```

**示例 3**：
```
输入：n = 10101
输出：183236316
```

## 解决方法

本题可以使用动态规划，主要思想是基于已有的序列再加入一个新的记录。

由于根据题意，“迟到”需要连续出现，而“缺席”是按照总数进行计算，我们可以将序列分成以下六种有效的情况：

1. 无缺席，无迟到，表示成 `*****`
2. 无缺席，一迟到，表示成 `****L`
3. 无缺席，两迟到，表示成 `***LL`
4. 缺席，无迟到，表示成`**A**`
5. 缺席，一迟到，表示成`**A*L`
6. 缺席，二迟到，表示成`**ALL`

那么所有的情况都可以递推出来。
```
比如说：无缺席，无迟到 = 之前无缺席，无迟到+之前无缺席，一迟到+之前无缺席，二迟到
即：****** = (***** + *) + (****L + *) + (***LL + *)
其他类似，可以找到规律。
```


```py
class Solution:
    def checkRecord(self, n: int) -> int:
        
        mod = 10**9+7
        
        # 从n=1开始，分别存储
        # [*****, ****l, ***ll, **a**, **a*l, **all]
        # 即“无缺席无迟到”，“无缺席一迟到”，“无缺席二迟到”，“缺席无迟到”，“缺席一迟到”，“缺席二迟到”
        dp = [1, 1, 0, 1, 0, 0]
        
        for i in range(1, n):
            tmp = [0, 0, 0, 0, 0, 0]
            
            # ****** = (*****+*) + (****L+*) + (***LL+*)
            tmp[0] = (dp[0]+dp[1]+dp[2])%mod
            
            # *****L = (*****+L)
            tmp[1] = dp[0]%mod
            
            # ****LL = (****L+L)
            tmp[2] = dp[1]%mod
            
            # **A*** = (*****+A) + (****L+A) + (***LL+A) + (**A**+*) + (**A*L+*) + (**ALL+*)
            tmp[3] = (dp[0]+dp[1]+dp[2]+dp[3]+dp[4]+dp[5])%mod
            
            # **A**L = (**A**+L)
            tmp[4] = dp[3]%mod
            
            # **A*LL = (**A*L+L)
            tmp[5] = dp[4]%mod
            
            dp = tmp
        
        return sum(dp)%mod
```