# [91. 解码方法](https://leetcode-cn.com/problems/decode-ways/)

一条包含字母 A-Z 的消息通过以下映射进行了编码：
```
'A' -> 1
'B' -> 2
...
'Z' -> 26
```
要解码已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，"11106" 可以映射为：
```
"AAJF" ，将消息分组为 (1 1 10 6)
"KJF" ，将消息分组为 (11 10 6)
```
注意，消息不能分组为  (1 11 06) ，因为 "06" 不能映射为 "F" ，这是由于 "6" 和 "06" 在映射中并不等价。

给你一个只含数字的 **非空** 字符串 `s` ，请计算并返回解码方法的总数。

 

**示例 1**：
```
输入：s = "12"
输出：2
解释：它可以解码为 "AB"（1 2）或者 "L"（12）。
```

**示例 2**：
```
输入：s = "226"
输出：3
解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
```


**示例 3**：
```
输入：s = "0"
输出：0
解释：没有字符映射到以 0 开头的数字。
含有 0 的有效映射是 'J' -> "10" 和 'T'-> "20" 。
由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。
```

**示例 4**：
```
输入：s = "06"
输出：0
解释："06" 不能映射到 "F" ，因为字符串含有前导 0（"6" 和 "06" 在映射中并不等价）。
```


**解决方法**

如果能计算一个串`a`的总数，那么再加入一个元素后，也能基于`a`的结果计算新的串的结果。所以，本题肯定使用**动态规划**。

假设现在遍历到`i`，`dp[i-1]`代表了`0 ~ i-1`内能有多少种组合方法：

1. `s[i] == '0'`，由于单个`0`无法解码，且`0`不能作为前缀，所以肯定需要和前面的元素进行组合
   1. `s[i-1] == '0'`，此时形成了`..., 0, 0, ...`的形式，无论如何分配，都无法进行解码，所以直接返回`0`表示无法解码
   2. `s[i-1] >= '3'`，此时就算能和前面的元素进行组合，但是也不在字母表的 26 个字母中，所以直接返回`0`表示无法解码
   3. `'1'<=s[i-1] and s[i-1]<='2'`，此时可以构成`10`或者`20`，由于在这种情况下，`s[i-1]`和`s[i]`是固定组合到一起，即可以分配成 *(0 ~ i-2), (i-1, i)*，而 *(0 ~ i-2)* 取决于`dp[i-2]`，所以`dp[i] = dp[i-2]`
    > 比如说 *"120"*，*dp[0]=1* (`1`只有一种组合)，*dp[1]=2* (`12`可以合起来也可以拆开，有两种组合)，而由于`20`必须组合到一起，所以只能分为`1`和`20`这样一种情况，*dp[i] = dp[2] = dp[0] = dp[i-2]*
2. `s[i] != '0'`
   1. `s[i-1] == '0'`，此时由于前面的元素`0`必定和别的元素进行组合，所以`s[i]`只能自己单独成为一个分组，即 *(0 ~ i-1), (i)*，而 *(0 ~ i-1)* 取决于`dp[i-1]`，所以`dp[i] = dp[i-1]`
   2. 计算前一个元素和本元素合起来的两位数字
      1. 如果该数字是 *1 ~ 26*，那么说明既可以拆开来组合，又可以合并起来，即 *(0 ~ i-1), (i)* 或 *(0 ~ i-2), (i-1, i)*，所以`dp[i] = dp[i-1] + dp[i-2]`
      2. 如果该数组不能被解码，则不能合并，只能两者拆开，即 *(0 ~ i-1), (i)*，`dp[i] = dp[i-1]`

```py
class Solution:
    def numDecodings(self, s: str) -> int:
        s = '9' + s     # 加一个前导元素，就可以避免在开头进行额外的处理
        n = len(s)
        dp = [1 for _ in range(n)]

        for i in range(1, n):
            # 如果遍历到当前元素为0
            if s[i] == '0':
                num = ord(s[i-1])-ord('0')
                if num==0 or num>=3:    # 情形1.1 + 1.2
                    return 0
                else:                   # 情形1.3
                    dp[i] = dp[i-2]
            
            # 如果为1~9
            else:
                if s[i-1]=='0':         # 情形2.1
                    dp[i] = dp[i-1]
                else:
                    num = (ord(s[i-1])-ord('0'))*10 + (ord(s[i])-ord('0'))
                    if num>26:          # 情形2.2.2
                        dp[i] = dp[i-1]
                    else:               # 情形2.2.1
                        dp[i] = dp[i-1] + dp[i-2]  

        return dp[-1]
```



由于该动态规划只涉及到`dp[i-2`, `dp[i-1]`和`dp[i]`，所以可以使用**滚动数组**来优化空间复杂度。

设置三个参数`a`, `b`和`c`来分别代表以上三个值。

```py
class Solution:
    def numDecodings(self, s: str) -> int:
        s = '9' + s     # 加一个前导元素，就可以避免在开头进行额外的处理
        n = len(s)
        a, b, c = 1, 1, 1

        for i in range(1, n):
            # 如果遍历到当前元素为0
            if s[i] == '0':
                num = ord(s[i-1])-ord('0')
                if num==0 or num>=3:    # 情形1.1 + 1.2
                    return 0
                else:                   # 情形1.3
                    c = a
            
            # 如果为1~9
            else:
                if s[i-1]=='0':         # 情形2.1
                    c = b
                else:
                    num = (ord(s[i-1])-ord('0'))*10 + (ord(s[i])-ord('0'))
                    if num>26:          # 情形2.2.2
                        c = b
                    else:               # 情形2.2.1
                        c = a + b
            
            # 每次循环结束后移动游标
            a, b = b, c 

        return c
```