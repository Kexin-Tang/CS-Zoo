# [611. 有效三角形的个数](https://leetcode-cn.com/problems/valid-triangle-number/)

给定一个包含非负整数的数组，你的任务是统计其中可以组成三角形三条边的三元组个数。

**示例**:
```
输入: [2,2,3,4]
输出: 3
解释:
有效的组合是: 
2,3,4 (使用第一个 2)
2,3,4 (使用第二个 2)
2,2,3
```

**注意**:
* 数组长度不超过1000。
* 数组里整数的范围为 [0, 1000]。


## 解决方法

由于本题和数组的下标无关，所以可以先排序。

我们假设三条边为 a, b, c, 并且排序后 *a≤b≤c*，而要满足三角形，则需要满足 *a+b＞c*，*a+c＞b* 以及 *b+c＞a*，考虑到a，b，c三者的大小关系，我们只需要考虑 *a+b>c* 这一条规则即可。

由于已经排过序，我们可以从小到大考虑，*i* 遍历 *[0 ~ n-2)*，*j* 遍历 *[i+1 ~ n-1)*。

对于 *k*，我们每次确定 *i* 之后，都先设置 `k=i+2`，然后再遍历 *j*，当`nums[i]+nums[j]>nums[k]`时，就将 *k* 向更大的值探索，直到越界/找到不符合条件的为之，那么 *[j, k-1]* 都是满足条件的，即`ans+=k-j-1`。此时 *j* 会指向下一个元素，此时 *k* 不必从 *j+1* 重新开始遍历，因为递增的关系，所以此时 *[j+1, k-1]* 一定是满足条件的，所以 *k* 从上一次停止的位置继续寻找是否满足条件即可。

**注意**：由于 *nums[i]* 可以取0，所以需要对某一条边是否为0进行判断，为0则跳过讨论。

```py
class Solution:
    def triangleNumber(self, nums: List[int]) -> int:
        nums.sort()
        ans = 0
        n = len(nums)
        # 如果没有三个元素，肯定构不成三角形
        if n<3:
            return 0
        
        for i in range(n-2):
            k = i+2
            for j in range(i+1, n-1):
                # 对边长取0进行判断
                if nums[i] == 0:
                    continue
                # k没有越界 and 满足三角形关系，就继续探索更大的值
                while k<n and nums[i]+nums[j]>nums[k]:
                    k += 1
                ans += k-j-1
        return ans
```