


二叉树的前序遍历为`(1-2-3-4-5-6-7-8-9)`，中序为`(2-3-1-6-7-8-5-9-4)`，则它的后续为?

【解析】3-2-8-7-6-9-5-4-1 


采用递归方式对顺序表进行快速排序，下列关于递归次数的叙述中，正确的是()

A. 递归次数与初始数据的排列次序无关

B. 每次划分后，先处理较长的分区可以减少递归次数

C. 每次划分后，先处理较短的分区可以减少递归次数

D. 递归次数与每次划分后得到的分区处理顺序无关

【解析】D。因为递归次数，取决于递归树，而递归树取决于轴枢的选择。树越平衡，递归次数越少。而对分区的长短处理顺序，影响的是递归时对栈的使用内存，而不是递归次数。



对递归程序的优化的一般的手段是？（A）

A. 尾递归优化

B. 循环优化

C. 堆栈优化

D. 停止值优化


【答案解析】：尾递归是指，在函数返回的时候，调用自身本身，并且return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。 尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。


以斐波那契数列为例子，普通的递归版本如下：

```c++
int fab(int n){ 
    if(n<3) return 1; 
    else    return fab(n-1)+fab(n-2);   
} 
```


具有"线性迭代过程"特性的递归---尾递归过程 

```c++
int fab(int n,int b1=1,int b2=1,int c=3){ 
    if(n<3)      return 1; 
    else 
    { 
        if(n==c) return b1+b2; 
        else     return fab1(n,b2,b1+b2,c+1); 
    } 
} 
```

以fab(4)为例子 

普通递归`fab(4)=fab(3)+fab(2)=fab(2)+fab(1)+fab(2)=3`  6次调用 

尾递归`fab(4,1,1,3)=fab(4,1,2,4)=1+2=3              `  2次调用



图的Depth-First Search(DFS)遍历思想实际上是二叉树()遍历方法的推广。

A. 先序

B. 中序

C. 后序

D. 层序


【答案解析】：深度先序，广度层次。



图的BFS生成树的树高比DFS生成树的树高()

A. 小或相等

B. 小

C. 大或相等

D. 大


【答案解析】：A。BFS是广度优先遍历，DFS是深度优先遍历。对于一些特殊的图，比如只有一个顶点的图，其BFS生成树的树高和DFS生成树的树高相等。 一般的图，根据图的BFS生成树和DFS树的算法思想，BFS生成树的树高比DFS生成树的树高小。



假设你只有100M的内存，需要对1G的数据进行排序，最合适的算法是？()

A. 归并排序

B. 插入排序

C. 快速排序

D. 冒泡排序


【答案解析】：A。因为内存不足，所以不能将所有数据存放在内存里，而是需要分段存储，将每小段进行合并。换句话说，需要使用外排序。而归并排序是最典型的外排序方法。



一个数据表有51233个元素，如果仅要求找出其中最大的12个元素，你觉得采用下列哪种算法比较节省时间?()

A. 堆排序

B. 希尔排序

C. 快速排序

D. 直接选择排序


【答案解析】：本题比较常见排序算法，TopK问题，堆排序，因此选A 



从n个数里面找最大的两个数理论上最少需要比较多少次?()

A. 2logn

B. 2logn -1

C. n+ logn -2

D. 2n-3


【答案解析】：C。在n个数中找到最大的两个数(topK问题使用堆排序)的最少比较次数，可以考虑堆排序，首先建堆是时间复杂度为O(n)或比较n-1次，找到最大的一个，然后调整堆，找到次大元素，比较logn-1，因此选C。



下面关于动态规划说法正确的是()

A. 他是利用子结构，进行自底而上的算法设计

B. 他需要后来多次计算的问题进行缓存，减少重复子问题的计算

C. 他所求问题的整体最优解可以通过一系列局部最优的选择

D. 他将分解后的子问题看成相互独立的.


【答案解析】：A。

    * 动态规划利用最优子结构，自底向上从子问题的最优解逐步构成整个问题的最优解。 

    * 用空间换时间只是一种技巧，不是动态规划的本质。 

    * 贪心选择是指所求问题的整体最优解可以通过一系列局部最优的选择,即贪心选择来达到。 

    * 与分治法不同的是，适合于用动态规划法求解的问题，经分解得到的子问题往往不是互相独立的，它们可能共享更小的子问题，被称为重叠子问题。
    
    
字符串 www.qq.com 所有非空子串（两个子串如果内容相同则只算一个）个数是()

A. 1024

B. 1018

C. 55

D. 50


【答案解析】：非空子串的个数共有n(n+1)/2个，n=10即55个，由于相同子串算一个，其中w(两次）, ww, q, ., 有重复。故 55 - 5 = 50。

*注意：区分子串和子序列。子串是连续的，而子序列是非连续的。即子序列类似于集合的概念，只要能随机组合即可；而子串必须是从中截取的一段。*
